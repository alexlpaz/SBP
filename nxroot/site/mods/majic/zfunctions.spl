////////////////////////////////////////////////////////////////////////////
// Module:      zfunctions.spl
// Author:      Henrique Grammelsbacher
// Created:     26-dez-2007
////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////
// 
//  Funções gerais de apoio
//
////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////
//  bloco_fim
//  Grava em log o fim de bloco de depuração
////////////////////////////////////////////////////////////////////////

bloco_fim(int depurar, string metodo) {
    if ( depurar==1 ) { 
        logf(SIGNIFICANT, "============================================================="); 
        logf(SIGNIFICANT, "%s Fim", metodo); 
        logf(SIGNIFICANT, "============================================================="); 
    } ;
} ;

////////////////////////////////////////////////////////////////////////
// Method:      z_bloco_fim()
// Author:      Henrique Grammelsbacher
// Created:     12/26/2007 5:20:50 PM
//
//  Description: Grava em log o fim de bloco de depuração
//
////////////////////////////////////////////////////////////////////////

z_bloco_fim(int depurar, string metodo) {
    if ( depurar==1 ) { 
        logf(SIGNIFICANT, "============================================================="); 
        logf(SIGNIFICANT, "%s Fim - %s", metodo, now()); 
        logf(SIGNIFICANT, "============================================================="); 
    } ;
} ;

////////////////////////////////////////////////////////////////////////
//  zcalcula_pri
//  Calcula prioridade em Issues, Incidents e Requests
////////////////////////////////////////////////////////////////////////
zcalcula_pri(int zimp, int zurg) {

    int zpri_new;
    
	// Define a prioridade da request conforme matriz
	// --------------------------- 
	// | IMPACTO       5   3   1 |
	// ---------------------------
	// ------------  -------------
	// | URGENCIA |  | PRIORIDADE|
	// |     3    |  | 1   2   3 |
	// |     2    |  | 2   3   4 |
	// |     1    |  | 3   4   4 |
	// ------------  -------------

	if ( zimp == 1 && zurg == 3 ) { zpri_new = 3 ; } ; 
	if ( zimp == 1 && zurg == 2 ) { zpri_new = 4 ; } ;
	if ( zimp == 1 && zurg == 1 ) { zpri_new = 4 ; } ;
	if ( zimp == 3 && zurg == 3 ) { zpri_new = 2 ; } ;
	if ( zimp == 3 && zurg == 2 ) { zpri_new = 3 ; } ;
	if ( zimp == 3 && zurg == 1 ) { zpri_new = 4 ; } ;
	if ( zimp == 5 && zurg == 3 ) { zpri_new = 1 ; } ;
	if ( zimp == 5 && zurg == 2 ) { zpri_new = 2 ; } ;
	if ( zimp == 5 && zurg == 1 ) { zpri_new = 3 ; } ;
	
    return zpri_new ;

} ;

////////////////////////////////////////////////////////////////////////
//  zcria_tarefa
//  Cria tarefas adicionais - processo de gerenciamento de mudanças
////////////////////////////////////////////////////////////////////////
zcria_tarefa( string tipo_tarefa, uuid responsavel, uuid grupo, int sequencia, 
                string descricao, string factory, int pai_id, int tarefa_paralela, string instrucoes, int depurar ) {

	int z;
	string metodo;
	metodo = 'z_cria_tarefa - ';

    // Entrada para debug mode
    if ( depurar==1 ) { 
        logf(SIGNIFICANT, "============================================================="); 
        logf(SIGNIFICANT, "%s Inicio", metodo); 
        logf(SIGNIFICANT, "%s ARG Count : %d", metodo, argc);
        for (z=0; z<argc; z+=1) {
            logf(SIGNIFICANT, "%s ARG #%s : %s", metodo, (string) z, (string) argv[z]);          
        } ;
        logf(SIGNIFICANT, "============================================================="); 
    } ;      

    ///////////////////////////////////////////////////////////////////////////////////////
    // Início do Código

    object group_leader, wf_adicional ;
    
    if ( depurar==1 ) { logf(SIGNIFICANT, "%s Se entrou aqui e pq tem que criar tarefa. Gerando group_leader", metodo ); } ;
    send_wait(0, top_object(), "get_co_group");
    if (msg_error()) {
        logf(ERROR, "erro ao instanciar group leader: %s", msg[0]);
  		bloco_fim(depurar, metodo);
  		return;
    } ;
    if ( depurar==1 ) { logf(SIGNIFICANT, "%s Group leader: %s", metodo, (string) msg[0]); } ;    
    group_leader = msg[0];

    if ( depurar==1 ) { logf(SIGNIFICANT, "%s Criando tarefa de aprovacao adicional", metodo ); } ;
    string novo_objeto ;
    if ( factory == "chg" ) {
        novo_objeto = "wf" ;
    } else {
        if ( factory == "iss" ) {
            novo_objeto = "iss_wf" ;
        } ;
    } ;
    
    if ( depurar==1 ) { logf(SIGNIFICANT, "%s Novo objeto e %s", metodo, novo_objeto ); } ;
    send_wait( 0, top_object(), "call_attr", novo_objeto, "get_new_dob", NULL, NULL, group_leader);
	if (msg_error()) {
	   logf(ERROR, "%s Erro ao gerar a tarefa de aprovacao adicional: %s", metodo, msg[0]);
	   bloco_fim(depurar, metodo) ;
       return;
	} ;
    wf_adicional = msg[0];

    if ( depurar==1 ) { logf(SIGNIFICANT, "%s Setando valores... se faltar algum sairemos fora.", metodo, novo_objeto ); } ;
    wf_adicional.sequence = (int) sequencia ; // posicao da tarefa de aprovacao adicional
	wf_adicional.task = tipo_tarefa ; // tipo da tarefa
	if ( factory == "chg" ) {
	   wf_adicional.chg = pai_id ;
	} else {
	   if ( factory == "iss" ) {
	       wf_adicional.iss = format("iss:%s", pai_id) ;
	    } ;
	} ;
	wf_adicional.object_type = factory ;
	wf_adicional.delete_flag = 0 ;
	wf_adicional.group_task = tarefa_paralela ;
	if ( !is_null(grupo) ) {
	   wf_adicional.group = grupo ;
	} ;
    wf_adicional.description = descricao ;
    wf_adicional.z_flag_auto = 1 ;
//    wf_adicional.z_str_instrucoes = instrucoes ;
    if ( !is_null(responsavel) ) {
        wf_adicional.assignee = responsavel ;
    } ;
    
    if ( depurar==1 ) { logf(SIGNIFICANT, "%s Gravando a nova tarefa no fluxo.", metodo ); } ;
    send_wait(0, group_leader, "checkin"); 
    if ( msg_error() ) {
      logf(ERROR, "%s Erro ao persistir tarefa de aprovacao adicional na posicao %s: %s. Tentando %s...", metodo, sequencia, msg[0], sequencia + 1);
      wf_adicional.sequence = (int) sequencia + 1;
      send_wait(0, group_leader, "checkin");
      if ( msg_error() ) {
        logf(ERROR, "%s Erro ao persistir tarefa de aprovacao adicional na segunda tentativa %s: %s...", metodo, msg[0]);
        bloco_fim(depurar, metodo);
        return;
      } ;
    } ;
    
    if ( depurar==1 ) { logf(SIGNIFICANT, "%s Resposta do checkin da tarefa adicional: %s", metodo, msg[0] ); } ;
	// Fim do codigo
	///////////////////////////////////////////////////////////////////////////////////////
	bloco_fim(depurar, metodo);
} ;

////////////////////////////////////////////////////////////////////////
// Method:      z_retorna_parametro
// Author:      Henrique Grammelsbacher
// Created:     9/29/2008 10:40:25 AM
// 
// Modified by: 
// Modified:
//
// Description: Retorna o uma option da tabela z_options de acordo com o sym 
//
// Parameters: 
//              zs_OptName        - sym da option
//              zs_OptValue       - Nome da campo a ser retornado da tabela options
//                                  - z_int_Valor          VALUE integer
//                                  - z_srl_ValorChgcat    SREL  string  --> chgcat
//                                  - z_srl_ValorCnt       SREL  uuid --> cnt
//                                  - z_srl_ValorGrp       SREL  uuid --> grp
//                                  - z_srl_ValorPcat      SREL  string  --> pcat
//                                  - z_str_Valor          VALUE string (100)
//                                  - z_str_Valor          VALUE string (100)
//
////////////////////////////////////////////////////////////////////////
string z_retorna_parametro(string zs_OptName, string zs_OptValue)
{
    
    
	int zi, zi_depurar;
	string zs_metodo, zs_wc;
	zs_metodo = 'z_retorna_parametro - ';

    // Alterar valor zi_depurar parar 1 para debug mode
    zi_depurar = 0;
        
    // Entrada para debug mode
    if ( zi_depurar==1 ) { 
        logf(SIGNIFICANT, "============================================================="); 
        logf(SIGNIFICANT, "%s Inicio", zs_metodo); 
        logf(SIGNIFICANT, "%s ARG Count : %d", zs_metodo, argc);
        for (zi=0; zi<argc; zi+=1) {
            logf(SIGNIFICANT, "%s ARG #%s : %s", zs_metodo, (string) zi, (string) argv[zi]);          
        } ;
        logf(SIGNIFICANT, "============================================================="); 
    } ;      
    ///////////////////////////////////////////////////////////////////////////////////////
    // Inicio do codigo

    object zo_objeto, zo_list;
    string zs_persid;
   
    //Consulta a z_option para obter  valor do grupo central
    zs_wc = format("z_str_nome='%s'", zs_OptName);
    if ( zi_depurar==1 ) { logf(SIGNIFICANT, "%s Lista de options: %s", zs_metodo,  zs_wc); } ;        
    send_wait( 0, top_object(), "call_attr", "z_parametros", "sync_fetch",  "STATIC", zs_wc, -1, 0);
    if ( msg_error() ) {
        logf(ERROR, "%s Erro ao definir lista de CRs: %s", zs_metodo,  msg[0]);
        bloco_fim(zi_depurar, zs_metodo);
        return;
    } ;
    zo_list = msg[0] ;
    
    //Consulta a primeira option retornada
    send_wait( 0, zo_list, "dob_by_index", "DEFAULT", 0,0);
    if ( msg_error() ) {
        logf(ERROR, "%s Erro ao identificar option: %s", zs_metodo,  msg[0]);
        bloco_fim(zi_depurar, zs_metodo);
        return;
    } ;
    zo_objeto = msg[0];
    
    //Pega o ID do grupo
    //Carrega valores do objeto
    if ( zi_depurar==1 ) { logf(SIGNIFICANT, "%s Submetendo consulta ao objeto: %s", zs_metodo, (string) zo_objeto ); } ;  
    send_wait(0, zo_objeto, "get_attr_vals", 1, zs_OptValue ) ;
    if ( msg_error() ) {
        logf(ERROR, "%s ERRO ao retornar atributos: %s", zs_metodo,  msg[0]);
        bloco_fim(zi_depurar, zs_metodo);
        return;
    } ;
    zs_persid = (string) msg[3];
    
    //Retorna o valor
    if ( zi_depurar==1 ) { logf(SIGNIFICANT, "%s Retornando valor '%s'", zs_metodo, zs_persid ); } ;
    bloco_fim(zi_depurar, zs_metodo);
    return zs_persid; 
          

    // Fim do codigo
    ///////////////////////////////////////////////////////////////////////////////////////
	bloco_fim(zi_depurar, zs_metodo);

} ;

////////////////////////////////////////////////////////////////////////
// Method:      z_calcula_data
// Author:      Henrique Grammelsbacher
// Created:     Wednesday, October 29, 2008 3:48:13 PM
// Modified by: 
// Modified:
//
// Description: 
//
//              Baseado no turno padrão, calcula a data final de um
//              prazo, baseado no esforço passado em zd_duration
//
// Parameters: 
//              zd_duration         - Tempo a ser somadao à data
//              zdt_referencia      - Data para calculo da data final
//
////////////////////////////////////////////////////////////////////////
date z_calcula_data(date zdt_referencia, duration zd_duration)
{
    
    
	int zi, zi_depurar;
	string zs_metodo;
	zs_metodo = 'zfunctions - ';

    // Alterar valor zi_depurar parar 1 para debug mode
    zi_depurar = 0;
        
    // Entrada para debug mode
    if ( zi_depurar==1 ) { 
        logf(SIGNIFICANT, "============================================================="); 
        logf(SIGNIFICANT, "%s Inicio", zs_metodo); 
        logf(SIGNIFICANT, "%s ARG Count : %d", zs_metodo, argc);
        for (zi=0; zi<argc; zi+=1) {
            logf(SIGNIFICANT, "%s ARG #%s : %s", zs_metodo, (string) zi, (string) argv[zi]);          
        } ;
        logf(SIGNIFICANT, "============================================================="); 
    } ;      
    ///////////////////////////////////////////////////////////////////////////////////////
    // Inicio do codigo
    string zs_wsPadrao, zs_sched, zs_persidPcat;
    object zo_wsPadrao;
    date zdt_dataFinal;
    
    //Identifica qual o workshift padrão
    zs_wsPadrao = z_retorna_option("ia_turno_padrao", "z_srl_ValorWrkshft");
                
    //instancia o ws e retorna a string com o turno
    //Instancia o objeto pello su persid
    if ( zi_depurar==1 ) { logf(SIGNIFICANT, "%s Instanciando objeto: %s", zs_metodo, zs_wsPadrao ); } ;        
    send_wait (0, top_object(), "call_attr", "wrkshft", "dob_by_persid", NULL, zs_wsPadrao);
    if ( msg_error() ) {
        logf(ERROR, "%s Erro ao instanciar objeto: %s", zs_metodo,  msg[0]);
        z_bloco_fim(zi_depurar, zs_metodo);
        return;
    } ;
    zo_wsPadrao=msg[0];
    
    //Carrega valores do objeto
    if ( zi_depurar==1 ) { logf(SIGNIFICANT, "%s Submetendo consulta ao objeto: %s", zs_metodo, (string) zo_wsPadrao ); } ;  
    send_wait(0, zo_wsPadrao, "get_attr_vals", 1, "sched" ) ;
    if ( msg_error() ) {
        logf(ERROR, "%s ERRO ao retornar atributos: %s", zs_metodo,  msg[0]);
        z_bloco_fim(zi_depurar, zs_metodo);
        return;
    } ;
    zs_sched = msg[3];
    
    //Caso não haja data de referencia, usa agora
    if ( is_empty(zdt_referencia) ) { 
        zdt_referencia = (date) now(); 
    } ;
    
    //Caso não haja duração, a duração é 0
    if ( is_empty(zd_duration) ) { 
        zd_duration = (duration) 0; 
    } ;
    
    //Soma a duracao informada na chamada da funcao no ticket
    zdt_dataFinal = workshift_work2abs(zs_sched, zdt_referencia, zd_duration);
    z_bloco_fim(zi_depurar, zs_metodo);
    
    return zdt_dataFinal; 

    // Fim do codigo
    ///////////////////////////////////////////////////////////////////////////////////////
	z_bloco_fim(zi_depurar, zs_metodo);

} ;

////////////////////////////////////////////////////////////////////////
// Method:      z_calcula_prazo
// Author:      Henrique Grammelsbacher
// Created:     Thursday, October 30, 2008 8:14:11 AM
// Modified by: 
// Modified:
//
// Description: 
//              Baseado no turno padrão, calcula o prazo em horas
//              uteis que ainda resta entre a data inicial e data
//              final
//
// Parameters: 
//              zdt_inicio       - Dada do inicio do periodo
//              zdt_fim          - Dada do fim do periodo
//
////////////////////////////////////////////////////////////////////////
duration z_calcula_prazo(date zdt_inicio, date zdt_fim, string zs_wrkshft)
{
    
    
	int zi, zi_depurar;
	string zs_metodo;
	zs_metodo = 'zfunctions - ';

    // Alterar valor zi_depurar parar 1 para debug mode
    zi_depurar = 0;
        
    // Entrada para debug mode
    if ( zi_depurar==1 ) { 
        logf(SIGNIFICANT, "============================================================="); 
        logf(SIGNIFICANT, "%s Inicio", zs_metodo); 
        logf(SIGNIFICANT, "%s ARG Count : %d", zs_metodo, argc);
        for (zi=0; zi<argc; zi+=1) {
            logf(SIGNIFICANT, "%s ARG #%s : %s", zs_metodo, (string) zi, (string) argv[zi]);          
        } ;
        logf(SIGNIFICANT, "============================================================="); 
    } ;      
    ///////////////////////////////////////////////////////////////////////////////////////
    // Inicio do codigo
    string zs_wsPadrao, zs_sched, zs_persidPcat;
    object zo_wsPadrao;
    date zdt_dataFinal;
    
    //Identifica qual o workshift padrão
    //zs_wsPadrao = z_retorna_option("ia_turno_padrao", "z_srl_ValorWrkshft");
    zs_wsPadrao = zs_wrkshft;
    //instancia o ws e retorna a string com o turno
    //Instancia o objeto pello su persid
    if ( zi_depurar==1 ) { logf(SIGNIFICANT, "%s Instanciando objeto: %s", zs_metodo, zs_wsPadrao ); } ;        
    send_wait (0, top_object(), "call_attr", "wrkshft", "dob_by_persid", NULL, zs_wsPadrao);
    if ( msg_error() ) {
        logf(ERROR, "%s Erro ao instanciar objeto: %s", zs_metodo,  msg[0]);
        z_bloco_fim(zi_depurar, zs_metodo);
        return;
    } ;
    zo_wsPadrao=msg[0];
    
    //Carrega valores do objeto
    if ( zi_depurar==1 ) { logf(SIGNIFICANT, "%s Submetendo consulta ao objeto: %s", zs_metodo, (string) zo_wsPadrao ); } ;  
    send_wait(0, zo_wsPadrao, "get_attr_vals", 1, "sched" ) ;
    if ( msg_error() ) {
        logf(ERROR, "%s ERRO ao retornar atributos: %s", zs_metodo,  msg[0]);
        z_bloco_fim(zi_depurar, zs_metodo);
        return;
    } ;
    zs_sched = msg[3];
    
    //Caso não haja data de referencia, usa agora
    if ( is_empty(zdt_inicio) ) { 
        zdt_inicio = (date) now(); 
    } ;
    if ( zi_depurar==1 ) { logf(SIGNIFICANT, "%s Data Inicio: '%s'", zs_metodo, zdt_inicio ); } ;    
    //Caso não haja duração, a duração é 0
    if ( is_empty(zdt_fim) ) { 
        zdt_fim  = (date) now(); 
    } ;
    if ( zi_depurar==1 ) { logf(SIGNIFICANT, "%s Data Fim: '%s'", zs_metodo, zdt_fim ); } ;

    //Soma a duracao informada na chamada da funcao no ticket
    zdt_dataFinal = workshift_abs2work(zs_sched, zdt_inicio, zdt_fim);
    if ( zi_depurar==1 ) { logf(SIGNIFICANT, "%s Data Final: '%s'", zs_metodo, zdt_dataFinal ); } ;
    
    z_bloco_fim(zi_depurar, zs_metodo);
    
    return zdt_dataFinal; 

    // Fim do codigo
    ///////////////////////////////////////////////////////////////////////////////////////
	z_bloco_fim(zi_depurar, zs_metodo);

} ;

////////////////////////////////////////////////////////////////////////
// Method:      z_is_in_shift.spl
// Author:      Henrique Grammelsbacher
// Created:     domingo, abril 19, 2009 10:54:43 
// Modified by: 
// Modified:
//
// Description: 
//              Determina se a data zd_data está dentro do Workshift zs_persidWs, retornando
//                  1 = data está dentro do Workshift
//                  0 =  data está fora do Workshift
//
// Parameters: 
//              zs_persidWs        - Persid do ws a ser testado
//              zd_data            - Data a ser verificada 
//
////////////////////////////////////////////////////////////////////////
int z_is_in_shift( string zs_persidWs, string zd_data )
{
    
    
	int zi, zi_depurar;
	string zs_metodo;
	zs_metodo = 'z_is_in_shift - ';

    // Alterar valor zi_depurar parar 1 para debug mode
    zi_depurar = 0;
        
    // Entrada para debug mode
    if ( zi_depurar==1 ) { 
        logf(SIGNIFICANT, "============================================================="); 
        logf(SIGNIFICANT, "%s Inicio", zs_metodo); 
        logf(SIGNIFICANT, "%s ARG Count : %d", zs_metodo, argc);
        for (zi=0; zi<argc; zi+=1) {
            logf(SIGNIFICANT, "%s ARG #%s : %s", zs_metodo, (string) zi, (string) argv[zi]);          
        } ;
        logf(SIGNIFICANT, "============================================================="); 
    } ;      
    ///////////////////////////////////////////////////////////////////////////////////////
    // Inicio do codigo
    string zs_sched;
    date zd_dataTeste;
    
    //Instancia o objeto pello su persid
    if ( zi_depurar==1 ) { logf(SIGNIFICANT, "%s Instanciando wrkshft: %s", zs_metodo, zs_persidWs ); } ;        
    send_wait (0, top_object(), "call_attr", "wrkshft", "dob_by_persid", NULL, zs_persidWs);
    if ( msg_error() ) {
        logf(ERROR, "%s Erro ao instanciar objeto: %s", zs_metodo,  msg[0]);
        z_bloco_fim(zi_depurar, zs_metodo);
        return;
    } ;
    zo_ws=msg[0];
    
    //Carrega valores do objeto
    if ( zi_depurar==1 ) { logf(SIGNIFICANT, "%s Submetendo consulta ao objeto: %s", zs_metodo, (string) zs_persidWs ); } ;  
    send_wait(0, zo_ws, "get_attr_vals", 1, "sched" ) ;
    if ( msg_error() ) {
        logf(ERROR, "%s ERRO ao retornar atributos: %s", zs_metodo,  msg[0]);
        z_bloco_fim(zi_depurar, zs_metodo);
        return;
    } ;
    zs_sched = msg[3];
    
    zd_dataTeste = (date) workshift_work2abs(zs_sched, (date) zd_data, (duration) 0);
    if ( zi_depurar==1 ) { logf(SIGNIFICANT, "%s Sched a ser compudato: '%s'", zs_metodo, zs_sched ); } ;
    if ( zi_depurar==1 ) { logf(SIGNIFICANT, "%s Data inicial: '%s', Data final: '%s'", zs_metodo, zd_data, zd_dataTeste ); } ;

    if ((date) zd_dataTeste == (date) zd_data) {
        if ( zi_depurar==1 ) { logf(SIGNIFICANT, "%s Isso é um período útil. Retorna True", zs_metodo ); } ;
        z_bloco_fim(zi_depurar, zs_metodo);
        return 1;
    } else {
        if ( zi_depurar==1 ) { logf(SIGNIFICANT, "%s Isso NÃO é um período útil. Retorna False", zs_metodo ); } ;
        z_bloco_fim(zi_depurar, zs_metodo);
        return 0;
    } ;
    
            

    // Fim do codigo
    ///////////////////////////////////////////////////////////////////////////////////////
	z_bloco_fim(zi_depurar, zs_metodo);

} ;


